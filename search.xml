<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>core-module-OpenCV(PART 1)</title>
      <link href="/2020/11/10/core-module-OpenCV(PART%201)/"/>
      <url>/2020/11/10/core-module-OpenCV(PART%201)/</url>
      
        <content type="html"><![CDATA[<p>I’ve been learning machine vision for a few days. But not until today do i decide to write something about it.</p><a id="more"></a><h2 id="1-Machine-Vision-amp-Computer-Vision"><a href="#1-Machine-Vision-amp-Computer-Vision" class="headerlink" title="1.Machine Vision&amp; Computer Vision"></a>1.Machine Vision&amp; Computer Vision</h2><p>First, I want to talk about Machine Vision and Computer Vision.</p><p>Although, there is a slight (at least in my understading) difference between MV and CV. It’s that machine vision focuses more on the process of getting the images or videos. It has a requirement of nearly 100% correctness on the results. People making studies in this field focuses on optimizing the devices capturing the vision information. While CV concentrates more on image processing, and the storage and usage of image data.<br>Nowadays, the image capturing devices are getting more and more electronical, MV is much closer to Computer Vision, for it needs the CV algorithms, AI and so on to optimize its data source. Meanwhile, CV also need to care about the conventional things like in CV, for it’s also important for CV to have a more explicit ‘VISION’. The differences between them is shrinking.</p><p>As is shown above, besides the vast amount of image processing algorithms, yet we still need to get familiar with the topics of illumination, lenses, cameras, interfaces between cameras and computers, along with 3D sensors. And in the next post (after OpenCV core module), i will talk about different ways of illumination.</p><h2 id="2-OpenCV-core-modules"><a href="#2-OpenCV-core-modules" class="headerlink" title="2.OpenCV core modules"></a>2.OpenCV core modules</h2><p>OpenCV is a very popular library in computer vision. It has interfaces for c(deprecated but suppported while not suggested)/c++, Python(very popular and easy to learn), Java, etc. And it can run on Windows/Linux Distros(including android of course)/macOS/iOS.</p><p>About the installation on different platforms, I will make a video about it and upload it to bilibili.com later on. And i will emit this part in this post.</p><p>The platform i chose for myself is Windows + Visual Studio 2019, using vc14 compiler for c++. Which is a normal combination for industial usages.</p><h3 id="2-1-Mat"><a href="#2-1-Mat" class="headerlink" title="2.1 Mat"></a>2.1 Mat</h3><h4 id="2-1-1-Mat-construction-and-destruction"><a href="#2-1-1-Mat-construction-and-destruction" class="headerlink" title="2.1.1 Mat construction and destruction"></a>2.1.1 Mat construction and destruction</h4><p>First of all, we need to make it clear that images are stored in computers in the form of matrix. Using digits to represent every pixel that you see.</p><p>And you will not be surprised that Mat is a very important class in OpenCV, for it is how the image is stored in your computer. Normally, it’s composed of two parts, the header part and the body part. The header part stores some information of the image matrix, like what kind of image it is. And it has a constant size. As for the body part, it stores a reference to the real data of the image, which is a matrix, like i mentioned before.<br>You may wonder why it uses a reference rather than the whole matrix. Imaging that you need to assign the value to many Mat objects. And the COPY CONSTRUTOR of the class will assign every thousands of values each time you initialize a Mat object. It wastes a lot of time. So using the reference is a very effective way of fetching the matrix you need. But it’s also dangerous. Because if you change the value of the matrix through the object, you will change the raw matrix. Thus OpenCV also makes functions for you to fully create a new Mat object copying all the values.<br>And we will take a look at several ways of initializing a Mat object.</p><pre><code>Mat A, C;                          // declaration, which just creates the header parts without assigning valuesA = imread(argv[1], IMREAD_COLOR); // read in a image in color mode, file path specified by the first argumentMat B(A);                          // Use the copy constructorC = A;                             // Use the assignment operator</code></pre><p>In image processing, we usually have the concept of ROI, region of interest, thus we can also assign part of a image to the object.</p><pre><code>Mat D (A, Rect(10, 10, 100, 100) ); // using a rectangleMat E = A(Range::all(), Range(1,3));// using row and column boundaries</code></pre><p>Finally, the copy functions:</p><pre><code>Mat F = A.clone();Mat G;A.copyTo(G);</code></pre><p>Some of you may wonder that, since we have the creation method, do we have the destructor functions like ~Mat() ?<br>The answer is yes, but you don’t need to call it on your own, because the library has automatic memory management. When it finds that in the later execution you don’t need the Mat any more, and the matrix is not referenced to by any Mat, they will be deleted. which is realized by the reference counter method, which is a very common way of memory management.</p><h4 id="storing-methods"><a href="#storing-methods" class="headerlink" title="storing methods"></a>storing methods</h4><p>Images can be stored in many methods like RGB, HSV, HSL and so on. In OpenCV, we specify it when we read in the image using imread. and we can transforme it to other format using ‘cvtColors’ function. We will talk about this in image operations.</p><h4 id="manually-create-a-Mat-object"><a href="#manually-create-a-Mat-object" class="headerlink" title="manually create a Mat object"></a>manually create a Mat object</h4><p>The Mat constructor can also be used here as a fucntion which has tons of overrides:</p><pre><code>Mat M(2,2, CV_8UC3, Scalar(0,0,255));</code></pre><p>or</p><pre><code>int sz[3] = {2,2,2};Mat L(3,sz, CV_8UC(1), Scalar::all(0));</code></pre><p>and manually with the create() function:</p><pre><code>M.create(4,4, CV_8UC(2));</code></pre><p>Also some specific matrix types:</p><pre><code>Mat E = Mat::eye(4, 4, CV_64F);Mat O = Mat::ones(2, 2, CV_32F);Mat Z = Mat::zeros(3,3, CV_8UC1);</code></pre><p>The CV_{digit}{type}C{channel} format specifies the structure of the Mat object, which means in each position of the matrix, it has a {channel} channel number of {digit} digits, of specific {type} like int, float, and so on.</p><p>There are also some other operations like reshape and instream:</p><pre><code>C = (Mat_&lt;double&gt;({0, -1, 0, -1, 5, -1, 0, -1, 0})).reshape(3);Mat C = (Mat_&lt;double&gt;(3,3) &lt;&lt; 0, -1, 0, -1, 5, -1, 0, -1, 0);</code></pre><h4 id="output-formatting"><a href="#output-formatting" class="headerlink" title="output formatting"></a>output formatting</h4><p>You can output the Mat in many ways(not demonstrate the image, just showing the value of each pixel). You can use a formatter like:</p><pre><code>format({Mat M}, Formatter::FMT_PYTHON\FMT_CSV\FMT_NUMPY\FMT_C)</code></pre><h4 id="TO-BE-CONTINUED"><a href="#TO-BE-CONTINUED" class="headerlink" title="TO BE CONTINUED"></a>TO BE CONTINUED</h4>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer vision </tag>
            
            <tag> machine vision </tag>
            
            <tag> machine learning </tag>
            
            <tag> programming </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zfs-and-raidz</title>
      <link href="/2019/08/03/zfs-and-raidz/"/>
      <url>/2019/08/03/zfs-and-raidz/</url>
      
        <content type="html"><![CDATA[<h3 id="ZFS-AND-RAID-Z"><a href="#ZFS-AND-RAID-Z" class="headerlink" title="ZFS AND RAID-Z"></a>ZFS AND RAID-Z</h3><a id="more"></a><p>First let’s look back to where zfs was born.<br>    <a href="https://en.wikipedia.org/wiki/ZFS" target="_blank" rel="noopener">wikipedia</a></p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nas </tag>
            
            <tag> filesystem </tag>
            
            <tag> raid-z </tag>
            
            <tag> freenas </tag>
            
            <tag> freebsd </tag>
            
            <tag> solaris </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>freenas-configuration</title>
      <link href="/2019/07/15/freenas-configuration/"/>
      <url>/2019/07/15/freenas-configuration/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>In freenas, you can configure jail, which is the same thing like chroot, or in fact, chroot is son of jail. Jail first appear in BSD flavor unix. And after you create a jail or more, you can add different plugins for each jail, and different jails won’t affect echo other. So you can create a gitlab local server in one jail and a ftpserver in another.<br>But you need to have a pool to create a jail first.</p><p>A pool is a virtual storage device in zfs. It’s like a windows volumn in some ways, but the volumn can include multiple storage devices. You can keep adding sotrage devices to a pool, but i don’t know if it has a restriction to the amount of devices. And note that the system will be installed to a boot pool which it creates itself, so remember to use a fast but small flash storage device to install the system, for that the boot pool won’t be used to do anything and the space will be wasted, in another way it affects the system program performance.<br>We will talk about raid-z in the next post. A raid system based on zfs.</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software </tag>
            
            <tag> nas </tag>
            
            <tag> personal cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>computer without graphic cards</title>
      <link href="/2019/07/15/computer-without-graphic-cards/"/>
      <url>/2019/07/15/computer-without-graphic-cards/</url>
      
        <content type="html"><![CDATA[<p> Today, I tried to remove the graphic card from my old computer, which uses xeon e3 1230v2, which does not contain a core graphics card and need a discrete gpu to light up.</p> <a id="more"></a><p> I installed a freenas on it, which has no gui, remotely controlled through web page.</p><p> After i removed the gpu, i plugged another pcie2nvme card with a samsung sm961 on it to the finally-free slot and boot it. It succeeded, and i can normally add the new sm961 to my zfs pool.</p><p> Though i know that many hardware like routers, like ssd controllers, don’t have a video output and they can function well, but on pc hardware, i see it for the first time. And i searched for it, it says, some old pc boards doesn’t support booting without video outputs, the support starts from these years.</p><p> And now i have a useless gtx750ti, i think i’m ready to tear it into nails.  :)</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hardware </tag>
            
            <tag> gpu </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
